<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Thread Synchronization — Single-file Simulation</title>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1320; --muted:#94a3b8; --accent:#60a5fa; --good:#34d399; --danger:#fb7185; --glass: rgba(255,255,255,0.04);
      --running:#60a5fa; --waiting:#f59e0b; --blocked:#f97316; --completed:#10b981;
    }
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,Arial;color:#e6eef8;background:linear-gradient(180deg,var(--bg),#071027);}
    .app{max-width:1200px;margin:24px auto;padding:20px;}
    header{display:flex;gap:16px;align-items:center;justify-content:space-between}
    h1{margin:0;font-size:20px}

    .controls{display:flex;gap:12px;flex-wrap:wrap;background:var(--glass);padding:12px;border-radius:12px;margin-top:12px;align-items:center}
    .control{display:flex;flex-direction:column;font-size:13px;color:var(--muted)}
    label{font-weight:600;color:#dbeafe;margin-bottom:6px}
    select,input[type=range]{padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6eef8}
    button{padding:8px 12px;border-radius:10px;border:0;cursor:pointer;background:var(--accent);color:#042a4f;font-weight:700}
    button.secondary{background:#243447;color:#cfe7ff}

    .grid{display:grid;grid-template-columns:2fr 1fr;gap:16px;margin-top:16px}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));padding:14px;border-radius:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}

    /* Threads area */
    .threads-wrap{display:flex;flex-direction:column;gap:12px}
    .thread-row{display:flex;gap:12px;align-items:center}
    .thread-card{min-width:140px;padding:10px;border-radius:10px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));display:flex;align-items:center;gap:10px;border-left:6px solid rgba(255,255,255,0.03)}
    .dot{width:12px;height:12px;border-radius:50%}
    .state-running{background:var(--running);box-shadow:0 0 12px rgba(96,165,250,0.25)}
    .state-waiting{background:var(--waiting)}
    .state-blocked{background:var(--danger)}
    .state-completed{background:var(--completed)}
    .pulse{animation:pulse 1.2s infinite}
    @keyframes pulse{0%{transform:scale(1);opacity:1}50%{transform:scale(1.06);opacity:0.8}100%{transform:scale(1);opacity:1}}

    .res-bar{height:14px;border-radius:8px;background:rgba(255,255,255,0.04);overflow:hidden}
    .res-fill{height:100%;transition:width 300ms ease}

    .queue{display:flex;gap:8px;flex-wrap:wrap}
    .queue .item{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:12px}

    /* Stats & Log */
    .stats{display:flex;gap:10px;flex-wrap:wrap}
    .stat{flex:1;min-width:120px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
    .log{height:260px;overflow:auto;background:rgba(1,6,12,0.4);padding:8px;border-radius:8px;font-family:monospace;font-size:13px;color:#cfe7ff}

    footer{margin-top:12px;color:var(--muted);font-size:12px}

    /* responsive */
    @media (max-width:900px){.grid{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Thread Synchronization — Single-file Simulation</h1>
        <div style="color:var(--muted);font-size:13px;margin-top:6px">Semaphore, Mutex, Monitor, Condition Variable — visual, interactive, and configurable</div>
      </div>
      <div style="text-align:right;color:var(--muted);font-size:13px">Created for interactive learning • Change settings live • Click Start</div>
    </header>

    <div class="controls">
      <div class="control">
        <label for="syncType">Synchronization Type</label>
        <select id="syncType">
          <option value="semaphore">Semaphore (N permits)</option>
          <option value="mutex">Mutex (1 permit)</option>
          <option value="monitor">Monitor (lock + condition)</option>
          <option value="condvar">Condition Variable (wait/signal)</option>
        </select>
      </div>

      <div class="control">
        <label for="threadCount">Thread count: <span id="threadCountLabel">6</span></label>
        <input id="threadCount" type="range" min="2" max="12" value="6" />
      </div>

      <div class="control">
        <label for="speed">Animation speed</label>
        <select id="speed">
          <option value="0.5">Very Slow</option>
          <option value="0.8">Slow</option>
          <option value="1" selected>Normal</option>
          <option value="1.6">Fast</option>
          <option value="2.6">Very Fast</option>
        </select>
      </div>

      <div style="display:flex;gap:8px;align-items:center;margin-left:auto">
        <button id="startBtn">Start</button>
        <button id="pauseBtn" class="secondary">Pause</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>
    </div>

    <div class="grid">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap">
          <div style="flex:1;min-width:280px">
            <h3 style="margin:0 0 8px 0">Simulation View</h3>
            <div class="threads-wrap" id="threadsArea">
              <!-- threads injected here -->
            </div>
          </div>

          <div style="width:260px">
            <h3 style="margin:0 0 8px 0">Resources & Queue</h3>
            <div style="margin-bottom:8px">
              <div style="display:flex;justify-content:space-between;font-size:13px;color:var(--muted)">
                <div>Available</div><div id="resourceAvailable">—</div>
              </div>
              <div class="res-bar" style="margin-top:6px"><div id="resFill" class="res-fill" style="width:0;background:linear-gradient(90deg,var(--accent),#7dd3fc)"></div></div>
            </div>

            <div style="margin-top:8px">
              <div style="color:var(--muted);font-size:13px;margin-bottom:6px">Waiting Queue</div>
              <div id="queueArea" class="queue"></div>
            </div>

            <div style="margin-top:12px">
              <h4 style="margin:0 0 6px 0">Mechanism Notes</h4>
              <div id="notes" style="font-size:13px;color:var(--muted);line-height:1.4"></div>
            </div>
          </div>
        </div>

        <hr style="border:none;height:8px;background:transparent;margin:12px 0">

        <div style="display:flex;gap:18px;flex-wrap:wrap;align-items:stretch">
          <div style="flex:1;min-width:240px">
            <h4 style="margin:2px 0 8px 0">Statistics</h4>
            <div class="stats">
              <div class="stat">
                <div style="font-size:12px;color:var(--muted)">Active (running)</div>
                <div id="statRunning" style="font-weight:800;font-size:18px">0</div>
              </div>
              <div class="stat">
                <div style="font-size:12px;color:var(--muted)">Waiting</div>
                <div id="statWaiting" style="font-weight:800;font-size:18px">0</div>
              </div>
              <div class="stat">
                <div style="font-size:12px;color:var(--muted)">Completed</div>
                <div id="statCompleted" style="font-weight:800;font-size:18px">0</div>
              </div>
            </div>
          </div>

          <div style="flex:1;min-width:240px">
            <h4 style="margin:2px 0 8px 0">Real-time Activity Log</h4>
            <div id="log" class="log"></div>
          </div>
        </div>

      </div>

      <div class="panel">
        <h3 style="margin:0 0 8px 0">Controls & Explanation</h3>
        <div style="font-size:13px;color:var(--muted);line-height:1.5">
          <p><strong>Semaphore:</strong> Limited number of permits. Threads acquire a permit to run and release when done.</p>
          <p><strong>Mutex:</strong> Exclusive access (semaphore with 1 permit).</p>
          <p><strong>Monitor:</strong> Lock + internal condition. Only one thread in monitor; others wait on condition.</p>
          <p><strong>Condition Variable:</strong> Threads can wait for a condition and be notified (signal/broadcast) to continue.</p>
        </div>

        <hr style="border:none;height:8px;background:transparent;margin:12px 0">
        <h4 style="margin:0 0 6px 0">Manual Controls</h4>
        <div style="display:flex;flex-direction:column;gap:8px">
          <div style="display:flex;gap:8px">
            <button id="stepBtn" class="secondary">Step (single tick)</button>
            <button id="signalBtn" class="secondary">Signal (CondVar)</button>
            <button id="broadcastBtn" class="secondary">Broadcast (CondVar)</button>
          </div>
          <div style="font-size:13px;color:var(--muted)">Change <em>Thread count</em> or <em>speed</em> while paused or running — simulation adapts.</div>
        </div>
      </div>
    </div>

    <footer>Tip: set speed to Very Slow to watch precise event order. Use Condition Variable mode to experiment with wait/signal semantics.</footer>
  </div>

  <script>
  // --- Utility ---
  const $ = id => document.getElementById(id);
  const fmtTime = () => new Date().toLocaleTimeString();

  // DOM
  const threadsArea = $('threadsArea');
  const queueArea = $('queueArea');
  const resFill = $('resFill');
  const resourceAvailable = $('resourceAvailable');
  const notes = $('notes');
  const logEl = $('log');
  const statRunning = $('statRunning');
  const statWaiting = $('statWaiting');
  const statCompleted = $('statCompleted');

  // Controls
  const syncTypeSelect = $('syncType');
  const threadCountRange = $('threadCount');
  const threadCountLabel = $('threadCountLabel');
  const startBtn = $('startBtn');
  const pauseBtn = $('pauseBtn');
  const resetBtn = $('resetBtn');
  const speedSelect = $('speed');
  const stepBtn = $('stepBtn');
  const signalBtn = $('signalBtn');
  const broadcastBtn = $('broadcastBtn');

  // Simulation state
  let threads = [];
  let waitingQueue = [];
  let permits = 3; // for semaphore default
  let runningCount = 0;
  let completedCount = 0;
  let tickInterval = null;
  let tickMs = 600;
  let running = false;

  // speed mapping (multiplier scales durations)
  function updateSpeed() {
    const mult = parseFloat(speedSelect.value);
    // base tick 600ms; faster -> smaller ms
    tickMs = Math.max(90, Math.round(600 / mult));
  }

  // Thread model
  function createThread(id){
    return {
      id,
      state:'idle', // idle, waiting, running, blocked, completed
      progress:0,
      work: Math.floor(5 + Math.random()*8), // steps to complete
      element: null
    }
  }

  function renderThreads(){
    threadsArea.innerHTML='';
    threads.forEach(t=>{
      const el = document.createElement('div');
      el.className='thread-row';
      el.innerHTML = `
        <div class="thread-card" id="t-${t.id}">
          <div class="dot" id="dot-${t.id}"></div>
          <div style="flex:1">
            <div style="display:flex;justify-content:space-between"><div style="font-weight:700">Thread-${t.id}</div><div style="font-size:12px;color:var(--muted)" id="st-${t.id}"></div></div>
            <div style="font-size:12px;color:var(--muted);margin-top:6px">Progress: <span id="pr-${t.id}">0</span>/<span id="to-${t.id}">${t.work}</span></div>
          </div>
        </div>
      `;
      t.element = el;
      threadsArea.appendChild(el);
      updateThreadUI(t);
    })
  }

  function updateThreadUI(t){
    const dot = $('dot-'+t.id);
    const stateLbl = $('st-'+t.id);
    const pr = $('pr-'+t.id);
    if(!dot || !stateLbl) return;
    pr.textContent = t.progress;
    stateLbl.textContent = t.state.toUpperCase();
    dot.className = 'dot';
    ['state-running','state-waiting','state-blocked','state-completed'].forEach(c=>dot.classList.remove(c));
    if(t.state==='running'){dot.classList.add('state-running','pulse');}
    else if(t.state==='waiting'){dot.classList.add('state-waiting');}
    else if(t.state==='blocked'){dot.classList.add('state-blocked');}
    else if(t.state==='completed'){dot.classList.add('state-completed');}
    else {dot.style.background='rgba(255,255,255,0.06)'}
  }

  function log(msg, type='info'){
    const time = fmtTime();
    const line = document.createElement('div');
    line.innerHTML = `<span style="color:var(--muted);font-size:12px">[${time}]</span> ${msg}`;
    if(type==='warn') line.style.color = '#ffd166';
    if(type==='err') line.style.color = '#ff8fa3';
    logEl.prepend(line);
  }

  function setNotesFor(type){
    if(type==='semaphore') notes.innerHTML = 'Semaphore: threads acquire permits (N). Example default: 3 permits. When none available threads wait.';
    if(type==='mutex') notes.innerHTML = 'Mutex: exclusive lock. One thread holds lock at a time.';
    if(type==='monitor') notes.innerHTML = 'Monitor: a protected region. Only one thread is active in monitor; others wait on conditions.';
    if(type==='condvar') notes.innerHTML = 'Condition Variable: threads may wait on a condition. Another thread signals to wake one or broadcast to wake all.';
  }

  // --- Mechanism logic ---
  function admitFromQueue(){
    const mode = syncTypeSelect.value;

    if(mode==='semaphore' || mode==='mutex'){
      while(waitingQueue.length>0 && permits>0){
        const t = waitingQueue.shift();
        acquirePermitFor(t);
      }
    } else if(mode==='monitor'){
      // monitor allows one inside; if nobody running, admit first waiting
      if(runningCount===0 && waitingQueue.length>0){
        const t = waitingQueue.shift();
        enterMonitor(t);
      }
    } else if(mode==='condvar'){
      // condvar: threads wait for signal; we do not auto-admit unless signaled
      // nothing to do here
    }
    renderQueue();
  }

  function acquirePermitFor(t){
    permits--;
    t.state='running';
    runningCount++;
    log(`Thread-${t.id} acquired permit and is RUNNING. (permits left: ${permits})`);
    updateThreadUI(t);
    updateResourceUI();
  }

  function releasePermitFrom(t){
    permits++;
    if(t.state!=='completed') t.state='idle';
    runningCount = Math.max(0, runningCount-1);
    log(`Thread-${t.id} released permit. (permits: ${permits})`);
    updateThreadUI(t);
    updateResourceUI();
    admitFromQueue();
  }

  function enterMonitor(t){
    // monitor modeled as single permit
    runningCount++;
    t.state='running';
    log(`Thread-${t.id} entered MONITOR (running).`);
    updateThreadUI(t);
  }

  function leaveMonitor(t){
    runningCount = Math.max(0, runningCount-1);
    t.state='idle';
    log(`Thread-${t.id} left MONITOR.`);
    updateThreadUI(t);
    admitFromQueue();
  }

  // Condition variable primitives
  let condWaiters = [];
  function condWait(t){
    t.state='waiting';
    condWaiters.push(t);
    log(`Thread-${t.id} WAITING on condition variable.`);
    updateThreadUI(t);
    renderQueue();
  }
  function condSignal(){
    if(condWaiters.length>0){
      const t = condWaiters.shift();
      t.state='running';
      log(`Signal woke up Thread-${t.id}`);
      updateThreadUI(t);
    }
  }
  function condBroadcast(){
    while(condWaiters.length>0){
      const t = condWaiters.shift();
      t.state='running';
      log(`Broadcast woke Thread-${t.id}`);
      updateThreadUI(t);
    }
  }

  // Render queue
  function renderQueue(){
    queueArea.innerHTML='';
    waitingQueue.forEach(t=>{
      const it = document.createElement('div'); it.className='item'; it.textContent = 'Thread-'+t.id; queueArea.appendChild(it);
    })
  }

  function updateResourceUI(){
    const total = (syncTypeSelect.value==='mutex')?1: (syncTypeSelect.value==='semaphore'?Math.max(1,Math.min(6,Math.ceil(threads.length/2))) : 0);
    // For mutex/semaphore show permits percentage
    if(syncTypeSelect.value==='semaphore' || syncTypeSelect.value==='mutex'){
      resourceAvailable.textContent = permits;
      const percent = Math.round((permits/total)*100);
      resFill.style.width = percent+'%';
    } else {
      resourceAvailable.textContent = runningCount>0?runningCount:0;
      resFill.style.width = runningCount>0?Math.min(100,(runningCount/threads.length)*100)+'%':'0%';
    }
  }

  function updateStats(){
    const running = threads.filter(t=>t.state==='running').length;
    const waiting = threads.filter(t=>t.state==='waiting' || t.state==='blocked').length;
    const completed = threads.filter(t=>t.state==='completed').length;
    statRunning.textContent = running;
    statWaiting.textContent = waiting;
    statCompleted.textContent = completed;
  }

  // --- Simulation tick ---
  function tick(){
    const mode = syncTypeSelect.value;

    // For each running thread, progress
    threads.forEach(t=>{
      if(t.state==='running'){
        t.progress++;
        if(Math.random()<0.08){ // occasional blocked moment
          t.state='blocked';
          log(`Thread-${t.id} got BLOCKED temporarily.`,'warn');
          updateThreadUI(t);
          // blocked -> after small timeout resume
          setTimeout(()=>{ if(t.state==='blocked'){ t.state='running'; updateThreadUI(t); log(`Thread-${t.id} unblocked and resumed.`); } }, Math.random()*1200);
        }
        if(t.progress>=t.work){
          t.state='completed';
          t.progress = t.work;
          completedCount++;
          // release permit if relevant
          if(mode==='semaphore' || mode==='mutex') releasePermitFrom(t);
          else if(mode==='monitor') leaveMonitor(t);
          else if(mode==='condvar') { /* condvar: thread done */ }
          log(`Thread-${t.id} COMPLETED.`,'info');
        }
        updateThreadUI(t);
      }
    });

    // Threads that are idle may try to acquire resource
    threads.forEach(t=>{
      if(t.state==='idle'){
        if(mode==='semaphore'){
          if(permits>0){ acquirePermitFor(t); }
          else { t.state='waiting'; if(!waitingQueue.includes(t)) waitingQueue.push(t); updateThreadUI(t); log(`Thread-${t.id} is WAITING for semaphore.`); }
        } else if(mode==='mutex'){
          if(permits>0) { acquirePermitFor(t); }
          else { t.state='waiting'; if(!waitingQueue.includes(t)) waitingQueue.push(t); updateThreadUI(t); log(`Thread-${t.id} is WAITING for mutex.`); }
        } else if(mode==='monitor'){
          // try to enter monitor if no one running
          if(runningCount===0){ enterMonitor(t); }
          else { t.state='waiting'; if(!waitingQueue.includes(t)) waitingQueue.push(t); updateThreadUI(t); }
        } else if(mode==='condvar'){
          // example scenario: threads check condition -> if false they wait
          // We'll randomly make some threads wait to demonstrate
          if(Math.random()<0.4){ condWait(t); }
          else { t.state='running'; runningCount++; log(`Thread-${t.id} running (condvar mode - no wait).`); updateThreadUI(t); }
        }
      }
    });

    updateResourceUI();
    renderQueue();
    updateStats();

    // stop when all done
    if(threads.every(t=>t.state==='completed')){
      stopSimulation();
      log('All threads completed — simulation stopped.');
    }
  }

  // --- Controls: start/stop/reset ---
  function startSimulation(){
    if(running) return;
    running = true;
    updateSpeed();
    tickInterval = setInterval(tick, tickMs);
    startBtn.textContent='Running'; startBtn.disabled=true;
    pauseBtn.textContent='Pause';
    log('Simulation started.');
  }

  function stopSimulation(){
    running = false;
    clearInterval(tickInterval); tickInterval = null;
    startBtn.textContent='Start'; startBtn.disabled=false;
    pauseBtn.textContent='Pause';
  }

  function pauseSimulation(){
    if(!running) return;
    clearInterval(tickInterval); tickInterval = null; running=false;
    pauseBtn.textContent='Resume';
    log('Simulation paused.');
  }

  function resumeSimulation(){
    if(running) return;
    updateSpeed();
    tickInterval = setInterval(tick, tickMs); running=true; pauseBtn.textContent='Pause'; log('Simulation resumed.');
  }

  function resetSimulation(){
    stopSimulation();
    threads = [];
    waitingQueue = [];
    permits = (syncTypeSelect.value==='mutex')?1:3;
    runningCount = 0; completedCount=0; condWaiters = [];
    const n = parseInt(threadCountRange.value,10);
    for(let i=1;i<=n;i++) threads.push(createThread(i));
    renderThreads(); updateResourceUI(); renderQueue(); updateStats();
    log('Simulation reset. Threads initialized: '+n);
  }

  // --- Event bindings ---
  syncTypeSelect.addEventListener('change', ()=>{
    const mode = syncTypeSelect.value;
    if(mode==='mutex'){ permits = 1; }
    else if(mode==='semaphore'){ permits = Math.max(1,Math.min(6,Math.ceil(threads.length/2))); }
    else { permits = 0; }
    setNotesFor(mode);
    resetSimulation();
  });

  threadCountRange.addEventListener('input', ()=>{ threadCountLabel.textContent = threadCountRange.value; });
  threadCountRange.addEventListener('change', ()=>{ resetSimulation(); });

  speedSelect.addEventListener('change', ()=>{ updateSpeed(); if(running){ clearInterval(tickInterval); tickInterval = setInterval(tick, tickMs); } });

  startBtn.addEventListener('click', ()=>{ startSimulation(); });
  pauseBtn.addEventListener('click', ()=>{ if(running) pauseSimulation(); else resumeSimulation(); });
  resetBtn.addEventListener('click', ()=>{ resetSimulation(); });

  stepBtn.addEventListener('click', ()=>{ tick(); });
  signalBtn.addEventListener('click', ()=>{ condSignal(); updateStats(); });
  broadcastBtn.addEventListener('click', ()=>{ condBroadcast(); updateStats(); });

  // init
  function init(){
    setNotesFor(syncTypeSelect.value);
    threadCountLabel.textContent = threadCountRange.value;
    resetSimulation();
  }
  init();
  </script>
</body>
</html>
